import { Magic, } from "@magic-sdk/react-native-bare";
import { Connector, normalizeChainId } from "@thirdweb-dev/wallets";
import { ethers } from "ethers";
import { defaultChains } from "@thirdweb-dev/chains";
export class MagicConnector extends Connector {
    constructor(options) {
        super();
        this.magicOptions = options;
        this.chains = options.chains ? options.chains : defaultChains;
        this.magicSdkConfiguration = options.magicSdkConfiguration;
        this.magicSDK = this.initializeMagicSDK({ chainId: options?.chainId || 0 });
    }
    async connect(options) {
        if (!this.magicOptions.apiKey) {
            throw new Error("Magic API Key is not provided.");
        }
        // if (options.chainId) {
        //   this.initializeMagicSDK({ chainId: options.chainId });
        // }
        await this.getProvider();
        this.setupListeners();
        this.emit("message", { type: "connecting" });
        // Check if there is a user logged in
        const isAuthenticated = await this.isConnected();
        // Check if we have a chainId, in case of error just assign 0 for legacy
        let chainId;
        try {
            chainId = await this.getChainId();
        }
        catch (e) {
            chainId = 0;
        }
        this.connectedChainId = chainId;
        // if there is a user logged in, return the user
        if (isAuthenticated) {
            return await this.getAddress();
        }
        const magic = this.getMagicSDK();
        // LOGIN WITH MAGIC LINK WITH EMAIL
        if (options.email) {
            await magic.auth.loginWithEmailOTP({
                email: options.email,
            });
        }
        // LOGIN WITH MAGIC LINK WITH PHONE NUMBER
        if (options.phoneNumber) {
            await magic.auth.loginWithSMS({
                phoneNumber: options.phoneNumber,
            });
        }
        const signer = await this.getSigner();
        let address = await signer.getAddress();
        if (!address.startsWith("0x")) {
            address = `0x${address}`;
        }
        return address;
    }
    async disconnect() {
        const magic = this.getMagicSDK();
        await magic.user.logout();
    }
    async getAddress() {
        const signer = await this.getSigner();
        const account = await signer.getAddress();
        if (account.startsWith("0x")) {
            return account;
        }
        return `0x${account}`;
    }
    async getSigner() {
        const provider = new ethers.providers.Web3Provider((await this.getProvider()));
        const signer = await provider.getSigner();
        return signer;
    }
    getProvider() {
        if (this.provider) {
            return this.provider;
        }
        const magic = this.getMagicSDK();
        this.provider = magic.rpcProvider;
        return this.provider;
    }
    switchChain(chainId) {
        const chain = this.chains.find((c) => c.chainId === chainId);
        if (!chain) {
            throw new Error("Chain not found");
        }
        if (this.connectedChainId !== chainId) {
            this.initializeMagicSDK({ chainId });
        }
        return Promise.resolve();
    }
    isConnected() {
        const magic = this.getMagicSDK();
        try {
            return magic.user.isLoggedIn();
        }
        catch (e) {
            return Promise.resolve(false);
        }
    }
    async setupListeners() {
        this.provider?.on("accountsChanged", () => {
            throw new Error("Accounts changed not implemented");
        });
        this.provider?.on("chainChanged", this.onChainChanged);
        this.provider?.on("disconnect", this.onDisconnect);
        return Promise.resolve();
    }
    updateChains(chains) {
        this.chains = chains;
    }
    // my methods
    onDisconnect() {
        this.emit("disconnect");
    }
    getMagicSDK() {
        if (!this.magicSDK) {
            return this.initializeMagicSDK();
        }
        return this.magicSDK;
    }
    initializeMagicSDK({ chainId } = {}) {
        if (chainId) {
            const chain = this.chains.find((c) => c.chainId === chainId);
            if (chain) {
                this.magicSdkConfiguration = this.magicSdkConfiguration || {};
                this.magicSdkConfiguration.network = {
                    rpcUrl: chain.rpc[0],
                    chainId: chain.chainId,
                };
            }
        }
        this.magicSDK = new Magic(this.magicOptions.apiKey, this.magicSdkConfiguration);
        this.provider = this.magicSDK.rpcProvider;
        return this.magicSDK;
    }
    async getChainId() {
        const networkOptions = this.magicSdkConfiguration?.network;
        if (typeof networkOptions === "object") {
            const chainID = networkOptions.chainId;
            if (chainID) {
                return normalizeChainId(chainID);
            }
        }
        throw new Error("Chain ID is not defined");
    }
    isChainUnsupported(chainId) {
        return !this.chains.some((x) => x.chainId === chainId);
    }
    onChainChanged(chainId) {
        const id = normalizeChainId(chainId);
        const unsupported = this.isChainUnsupported(id);
        this.emit("change", { chain: { id, unsupported } });
    }
}
